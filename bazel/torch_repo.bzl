"""Repository rule to setup a torch repo."""

_BUILD_TEMPLATE = """
# Generated by //bazel:torch_repo.bzl

load("@//bazel:torch_targets.bzl", "define_torch_targets")

package(
    default_visibility = [
        "//visibility:public",
    ],
)

define_torch_targets()
""".lstrip()

def _get_url_basename(url):
    basename = url.rpartition("/")[2]

    # Starlark doesn't have any URL decode functions, so just approximate
    # one with the cases we see.
    return basename.replace("%2B", "+")

def _torch_repo_impl(rctx):
    rctx.file("BUILD.bazel", _BUILD_TEMPLATE)

    env_torch_whl = rctx.os.environ.get("TORCH_WHL", "")

    urls = None
    local_path = None
    if env_torch_whl:
        if env_torch_whl.startswith("http"):
            urls = [env_torch_whl]
        else:
            local_path = rctx.path(env_torch_whl)
    else:
        dist_dir = rctx.workspace_root.get_child(rctx.attr.dist_dir)

        if dist_dir.exists:
            for child in dist_dir.readdir():
                # For lack of a better option, take the first match
                if child.basename.endswith(".whl"):
                    local_path = child
                    break

    if not local_path and not urls:
        fail((
            "No torch wheel source configured:\n" +
            "* Set TORCH_WHL environment variable to a local path or URL.\n" +
            "* Or ensure the {dist_dir} directory is present with a torch wheel." +
            "\n"
        ).format(
            dist_dir = dist_dir,
        ))

    if local_path:
        whl_path = local_path
        if not whl_path.exists:
            fail("File not found: {}".format(whl_path))

        # The dist/ directory is necessary for XLA's python_init_repositories
        # to discover the wheel and add it to requirements.txt
        rctx.symlink(whl_path, "dist/{}".format(whl_path.basename))
    elif urls:
        whl_basename = _get_url_basename(urls[0])

        # The dist/ directory is necessary for XLA's python_init_repositories
        # to discover the wheel and add it to requirements.txt
        whl_path = rctx.path("dist/{}".format(whl_basename))
        result = rctx.download(
            url = urls,
            output = whl_path,
        )
        if not result.success:
            fail("Failed to download: {}", urls)

    # Extract into the repo root. Also use .zip as the extension so that extract
    # recognizes the file type.
    # Use the whl basename so progress messages are more informative.
    whl_zip = whl_path.basename.replace(".whl", ".zip")
    rctx.symlink(whl_path, whl_zip)
    rctx.extract(whl_zip)
    rctx.delete(whl_zip)

torch_repo = repository_rule(
    implementation = _torch_repo_impl,
    doc = """
Creates a repository with torch headers, shared libraries, and wheel
for integration with Bazel.
""",
    attrs = {
        "dist_dir": attr.string(
            doc = """
Directory with a prebuilt torch wheel. Typically points to a source checkout
that built a torch wheel. Relative paths are relative to the workspace root.
""",
        ),
    },
    environ = ["TORCH_WHL"],
)
