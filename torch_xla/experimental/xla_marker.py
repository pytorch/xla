import dataclasses
import json
from dataclasses import dataclass
from typing import Dict

import torch
import torch._dynamo as torchdynamo
from torch.library import impl
import torch_xla
from torch_xla.core.xla_model import XLA_LIB

XLA_LIB.define(
    "mark_tensor(Tensor x, str name, int pos, str id, bool is_input, Any? attr=None) -> Tensor"
)


@dataclass
class BoundaryMetadata:
  name: str  # Name of the Patttern.
  pos: int  # Arg/return position.
  id: str  # Patten instance id.
  is_input: bool = True  # If the marked tensor is input/output.
  attr: dict = None  # Attribute of the pattern, expected to be attached to output.


class BoundaryMetadataSerializer(json.JSONEncoder):

  def default(self, obj):
    if dataclasses.is_dataclass(obj):
      return dataclasses.asdict(obj)
    return super().default(obj)


def _assert_valid_composite_attr(attr):
  if attr is None:
    return
  if not isinstance(attr, dict):
    raise ValueError("Composite attr must be a Python dictionary.")

  for k, v in attr.items():
    if not isinstance(k, str):
      raise ValueError("Composite attr name must be a Python str.")
    if type(k) not in (str, float, int, bool):
      raise ValueError(
          "Composite attr value must be either Python str, float, int, or bool."
      )


@torchdynamo.assume_constant_result
def serialize_composite_attr(attr: Dict):
  if attr is None:
    return None
  _assert_valid_composite_attr(attr)
  return tuple(attr.items())


@torchdynamo.assume_constant_result
def deserialize_composite_attr(attr) -> Dict:
  if attr is None:
    return None
  return dict(attr)


@impl(XLA_LIB, "mark_tensor", "XLA")
def mark_tensor_xla(x: torch.Tensor,
                    name: str,
                    pos: int,
                    id: str,
                    is_input: bool,
                    attr=None):
  """Attach pattern boundary metadata to a XLA Tensor.

  Args:
      x: torch.Tensor (On XLA device) - the marked tensor.
      name: str - The name of the pattern, it will be the name of the stablehlo composite op.
      pos: int - Input/output Position of the annotated tensor in the pattern.
      id: str - Unique identifier of the pattern instance.
      is_input: bool - If the annotated tensor is the input to the pattern.
      attr - Attribute of the pattern. It must be a value generated by serialize_composite_attr
             and will be passed down to the attribute field in the stablehlo composite. 
  """
  attr = deserialize_composite_attr(attr)
  _assert_valid_composite_attr(attr)
  pattern_info = BoundaryMetadata(name, pos, id, is_input, attr)
  return torch_xla._XLAC._xla_mark_tensor(
      x, json.dumps(pattern_info, cls=BoundaryMetadataSerializer))


@impl(XLA_LIB, "mark_tensor", "CompositeExplicitAutograd")
def mark_tensor(x: torch.Tensor,
                name: str,
                pos: int,
                id: str,
                is_input: bool,
                attr=None):
  # Do nothing for non-xla tensor.
  return x


@impl(XLA_LIB, "mark_tensor", "Meta")
def mark_tensor_meta(x: torch.Tensor,
                     name: str,
                     pos: int,
                     id: str,
                     is_input: bool,
                     attr=None):
  return torch.empty_like(x)
